import java.util.*;
import java.io.*;

class Nodo<T> {
	private T valor;
	private Nodo<T> siguiente;

	public Nodo() {
		this.valor = null;
		this.siguiente = null;
	}

	public Nodo(T valor) {
		this.valor = valor;
		this.siguiente = null;
	}

	public Nodo(T valor, Nodo<T> siguiente) {
		this.valor = valor;
		this.siguiente = siguiente;
	}

	public T getValor() {
		return valor;
	}

	public void setValor(T valor) {
		this.valor = valor;
	}

	public Nodo<T> getSiguiente() {
		return siguiente;
	}

	public void setSiguiente(Nodo<T> siguiente) {
		this.siguiente = siguiente;
	}

}//proporcionado por la guia.

class PilaEnlazada<T> {
	//atributos
	Nodo<T> tope;


	//Metodos
	public void push(T valor) {
		Nodo<T> node = new Nodo<>(valor, tope);
		tope = node;
	}//creo un nodo (node) y lo nombro mi tope

	public T pop() {
    if (isEmpty()) {
        throw new RuntimeException("La pila está vacía");
    }
    T valor = tope.getValor();
    tope = tope.getSiguiente();
    return valor;
}//verifico si ewsta vacio, si lo esta imprimo el mensaje, de lo contrario creo el nuevo tope


	public T peek() {
    if (isEmpty()) {
        throw new RuntimeException("La pila está vacía");
    }
    return tope.getValor();
}

    public boolean isEmpty() {
    return tope == null;
}


	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("[");
		Nodo<T> actual = tope;

		while (actual != null) {
			sb.append(actual.getValor());
			actual = actual.getSiguiente();
			if (actual != null) {
				sb.append(", ");
			}
		}

		sb.append("]");
		return sb.toString();
	}
}//listo

class ColaEnlazada<T> {
    Nodo<T> inicio; // apunta al primer nodo de la cola

    public boolean add(T valor) {
        Nodo<T> nuevo = new Nodo<>(valor, null);
        if (isEmpty()) {
            inicio = nuevo;
        } else {
            Nodo<T> actual = inicio;
            while (actual.getSiguiente() != null) {
                actual = actual.getSiguiente();
            }
            actual.setSiguiente(nuevo);
        }
        return true;
    }

    public T poll() {
        if (isEmpty()) {
            throw new RuntimeException("La cola está vacía");
        }
        T valor = inicio.getValor();
        inicio = inicio.getSiguiente();
        return valor;
    }

    public T peek() {
        if (isEmpty()) {
            throw new RuntimeException("La cola está vacía");
        }
        return inicio.getValor();
    }

    public boolean isEmpty() {
        return inicio == null;
    }
}

class Main {
    static long semilla = 42; 
    static int numAlertas = 50;    // numero fijo de alertas
    static int limiteRecursion = 3;

    static ColaEnlazada<Alerta> colaDeAlertas;
    static Random rand;

    public static void generarAlertas(int numAlertas, double probFallo) {
        colaDeAlertas = new ColaEnlazada<>();
        for (int i = 1; i <= numAlertas; i++) {
            colaDeAlertas.add(new Alerta("Alerta" + i, probFallo));
        }
    }

    // Retorna [resueltas, fallidas, tiempoEjecucionnnss]
    public static long[] iniciarSimulacion(double probFallo, int limite) {
        rand = new Random(semilla); 
        PilaEnlazada<Alerta> pila = new PilaEnlazada<>();
        generarAlertas(numAlertas, probFallo);

        int resueltas = 0;
        int fallidas = 0;

        long inicio = System.nanoTime();

        while (!colaDeAlertas.isEmpty()) {
            Alerta alerta = colaDeAlertas.poll();
            pila.push(alerta);
            boolean resultado = alerta.procesarLlamada(pila, limite);

            if (resultado) resueltas++;
            else fallidas++;
        }

        long fin = System.nanoTime();
        long tiempo = fin - inicio;

        return new long[]{resueltas, fallidas, tiempo};
    }

    public static void main(String[] args) {
        //Parte 1 
        System.out.println("---- Parte 1: Impacto del Limite de Recursion ----");
        double probFijo = 0.1;
        int[] limites = {5, 10, 15, 50};

        System.out.println("Limite\tResueltas\tFallidas\tTiempo(nns)");
        for (int limite : limites) {
            long[] resultados = iniciarSimulacion(probFijo, limite);
            System.out.println(limite + "\t" + resultados[0] + "\t\t" + resultados[1] + "\t\t" + resultados[2]);
        }

        //Parte 2
        System.out.println("\n---- Parte 2: Impacto de la Probabilidad de Fallo ----");
        int limiteFijo = 20;
        double[] probs = {0.01, 0.05, 0.1, 0.3};

        System.out.println("ProbFallo\tResueltas\tFallidas\tTiempo(nns)");
        for (double p : probs) {
            long[] resultados = iniciarSimulacion(p, limiteFijo);
            System.out.println(p + "\t\t" + resultados[0] + "\t\t" + resultados[1] + "\t\t" + resultados[2]);
        }
    }
}



class Alerta {
    String nombre;
    double probFallo;
    int limiteAlertas;

    public Alerta(String nombre, double probFallo) {
        this.nombre = nombre;
        this.probFallo = probFallo;
        this.limiteAlertas = Main.limiteRecursion;
    }


    private int calcularProfundidad(PilaEnlazada<Alerta> pila) {
        int count = 0;
        Nodo<Alerta> actual = pila.tope;
        while (actual != null) {
            count++;
            actual = actual.getSiguiente();
        }
        return count;
    }

    public boolean procesarLlamada(PilaEnlazada<Alerta> pila, int limite) {
        double r = Main.rand.nextDouble();

        // Caso base
        if (calcularProfundidad(pila) >= limite) {
            return true;
        }

        // Caso de fallo aleatorio
        if (r < probFallo) {
            return false;
        } else {
            // Paso recursivo
            Alerta nueva = new Alerta(nombre + "_retry", probFallo);
            pila.push(nueva);
            return nueva.procesarLlamada(pila, limite);
        }
    }
}



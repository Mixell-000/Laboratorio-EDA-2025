import java.util.*;
import java.io.*;

class Movie {
	// atributos
	String title;
	String director;
	String genre;
	int releaseYear;
	double rating;

	// Constructor
	Movie(String title, String director, String genre, int releaseYear, double rating) {
		this.title = title;
		this.director = director;
		this.genre = genre;
		this.releaseYear = releaseYear;
		this.rating = rating;
	}
}

class MovieCatalog {

	// atributos
	ArrayList<Movie> movies;
	String sortedByAttribute;

	// Constructor
	MovieCatalog(ArrayList<Movie> movies) {
		this.movies = movies;
		this.sortedByAttribute = null;
	}

	// Metodos
	public ArrayList<Movie> getMoviesByRating(double rating) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("rating".equalsIgnoreCase(sortedByAttribute)) {
			// busqueda binaria
			int left = 0;
			int right = movies.size() - 1;

			while (left <= right) {
				int mid = (left + right) / 2;
				double midRating = movies.get(mid).rating;

				if (Math.abs(midRating - rating) <= 0.1) {

					for (int i = mid; i >= 0 && Math.abs(movies.get(i).rating - rating) <= 0.1; i--) {
						if (!result.contains(movies.get(i))) result.add(movies.get(i));
					}
					for (int i = mid + 1; i < movies.size() && Math.abs(movies.get(i).rating - rating) <= 0.1; i++) {
						result.add(movies.get(i));
					}
					break;
				} else if (midRating < rating) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
		} else {
			// busqueda lineal
			for (int i = 0; i < movies.size(); i++) {
				if (Math.abs(movies.get(i).rating - rating) <= 0.1) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}//si esta ordenado por rating busqueda binaria, de lo contrario lineal

	public ArrayList<Movie> getMoviesByRatingRange(double lowerRating, double higherRating) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("rating".equalsIgnoreCase(sortedByAttribute)) {
			for (int i = 0; i < movies.size(); i++) {
				double r = movies.get(i).rating;
				if (r >= lowerRating && r <= higherRating) {
					result.add(movies.get(i));
				}
			}
		} else {
			for (int i = 0; i < movies.size(); i++) {
				double r = movies.get(i).rating;
				if (r >= lowerRating && r <= higherRating) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}//si esta ordenado por rating busqueda binaria, de lo contrario lineal


	public ArrayList<Movie> getMoviesByGenre(String genre) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("genre".equalsIgnoreCase(sortedByAttribute)) {
			int left = 0;
			int right = movies.size() - 1;

			while (left <= right) {
				int mid = (left + right) / 2;
				int cmp = movies.get(mid).genre.compareToIgnoreCase(genre);

				if (cmp == 0) {
					for (int i = mid; i >= 0 && movies.get(i).genre.equalsIgnoreCase(genre); i--) {
						result.add(movies.get(i));
					}
					for (int i = mid + 1; i < movies.size() && movies.get(i).genre.equalsIgnoreCase(genre); i++) {
						result.add(movies.get(i));
					}
					break;
				} else if (cmp < 0) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
		} else {
			for (int i = 0; i < movies.size(); i++) {
				if (movies.get(i).genre.equalsIgnoreCase(genre)) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}


	public ArrayList<Movie> getMoviesByDirector(String director) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("director".equalsIgnoreCase(sortedByAttribute)) {
			int left = 0, right = movies.size() - 1;
			while (left <= right) {
				int mid = (left + right) / 2;
				int cmp = movies.get(mid).director.compareToIgnoreCase(director);

				if (cmp == 0) {
					for (int i = mid; i >= 0 && movies.get(i).director.equalsIgnoreCase(director); i--) {
						result.add(movies.get(i));
					}
					for (int i = mid + 1; i < movies.size() && movies.get(i).director.equalsIgnoreCase(director); i++) {
						result.add(movies.get(i));
					}
					break;
				} else if (cmp < 0) left = mid + 1;
				else right = mid - 1;
			}
		} else {
			for (int i = 0; i < movies.size(); i++) {
				if (movies.get(i).director.equalsIgnoreCase(director)) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}


	public ArrayList<Movie> getMoviesByYear(int year) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("year".equalsIgnoreCase(sortedByAttribute)) {
			int left = 0, right = movies.size() - 1;
			while (left <= right) {
				int mid = (left + right) / 2;
				int midYear = movies.get(mid).releaseYear;

				if (midYear == year) {
					for (int i = mid; i >= 0 && movies.get(i).releaseYear == year; i--) {
						result.add(movies.get(i));
					}
					for (int i = mid + 1; i < movies.size() && movies.get(i).releaseYear == year; i++) {
						result.add(movies.get(i));
					}
					break;
				} else if (midYear < year) left = mid + 1;
				else right = mid - 1;
			}
		} else {
			for (int i = 0; i < movies.size(); i++) {
				if (movies.get(i).releaseYear == year) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}












public void sortByAlgorithm(String algorithm, String attribute) {
    // Obtener el comparador adecuado según el atributo
    Comparator<Movie> comparator = getComparator(attribute);
    
    // Seleccionar algoritmo de ordenamiento (solo uno de cada categoría)
    switch (algorithm.toLowerCase()) {
        case "insertionsort":
            insertionSort(comparator);
            break;
            
        case "selectionsort":
            selectionSort(comparator);
            break;
            
        case "mergesort":
            mergeSort(comparator);
            break;
            
        case "quicksort":
            quickSort(comparator);
            break;
            
        case "radixsort":
            if ("year".equals(attribute)) {
                radixSortByYear();
            } else {
                // Para atributos no numéricos, usar Collections.sort
                Collections.sort(movies, comparator);
            }
            break;
        default:
            // Si no se reconoce el algoritmo, usar Collections.sort
            Collections.sort(movies, comparator);
            break;
    }
    
    // Actualizar el atributo de ordenamiento
    sortedByAttribute = attribute;
}



public Comparator<Movie> getComparator(String attribute) {
    switch (attribute.toLowerCase()) {
        case "title":
            return new Comparator<Movie>() {
                public int compare(Movie m1, Movie m2) {
                    return m1.title.compareToIgnoreCase(m2.title);
                }
            };
        case "director":
            return new Comparator<Movie>() {
                public int compare(Movie m1, Movie m2) {
                    return m1.director.compareToIgnoreCase(m2.director);
                }
            };
        case "genre":
            return new Comparator<Movie>() {
                public int compare(Movie m1, Movie m2) {
                    return m1.genre.compareToIgnoreCase(m2.genre);
                }
            };
        case "year":
            return new Comparator<Movie>() {
                public int compare(Movie m1, Movie m2) {
                    return Integer.compare(m1.releaseYear, m2.releaseYear);
                }
            };
        case "rating":
        default:
            return new Comparator<Movie>() {
                public int compare(Movie m1, Movie m2) {
                    return Double.compare(m1.rating, m2.rating);
                }
            };
    }
}



//METODOS AUXILIARES PARA EL SORTBYALGORITMH

// InsertionSort
public void insertionSort(Comparator<Movie> comparator) {
    for (int i = 1; i < movies.size(); i++) {
        Movie key = movies.get(i);
        int j = i - 1;
        
        while (j >= 0 && comparator.compare(movies.get(j), key) > 0) {
            movies.set(j + 1, movies.get(j));
            j--;
        }
        movies.set(j + 1, key);
    }
}

// SelectionSort
public void selectionSort(Comparator<Movie> comparator) {
    for (int i = 0; i < movies.size() - 1; i++) {
        int indiceMenor = i;
        for (int j = i + 1; j < movies.size(); j++) {
            if (comparator.compare(movies.get(j), movies.get(indiceMenor)) < 0) {
                indiceMenor= j; 
            }
        }
        Movie temp = movies.get(indiceMenor);
        movies.set(indiceMenor, movies.get(i));
        movies.set(i, temp);
    }
}

// QuickSort 
public void quickSort(Comparator<Movie> comparator) {
    quickSortRecursivo(0, movies.size() - 1, comparator);
}

private void quickSortRecursivo(int inicio, int fin, Comparator<Movie> comparator) {
    if (inicio >= fin) return;
    
    Movie pivote = movies.get(fin);
    
    int posicionPivote = inicio - 1; 
    
    for (int i = inicio; i < fin; i++) {

        if (comparator.compare(movies.get(i), pivote) < 0) {
            posicionPivote++; 

            Movie temp = movies.get(posicionPivote);
            movies.set(posicionPivote, movies.get(i));
            movies.set(i, temp);
        }
    }
    
    posicionPivote++;
    Movie temp = movies.get(posicionPivote);
    movies.set(posicionPivote, movies.get(fin));
    movies.set(fin, temp);
    

    quickSortRecursivo(inicio, posicionPivote - 1, comparator);
    quickSortRecursivo(posicionPivote + 1, fin, comparator);
}







// MergeSort 
public void mergeSort(Comparator<Movie> comparator) {
    mergeSort(0, movies.size() - 1, comparator);
}

public void mergeSort(int left, int right, Comparator<Movie> comparator) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(left, mid, comparator);
        mergeSort(mid + 1, right, comparator);
        merge(left, mid, right, comparator);
    }
}

public void merge(int left, int mid, int right, Comparator<Movie> comparator) {
    ArrayList<Movie> temp = new ArrayList<Movie>();
    int i = left, j = mid + 1;
    
    while (i <= mid && j <= right) {
        if (comparator.compare(movies.get(i), movies.get(j)) <= 0) {
            temp.add(movies.get(i));
            i++;
        } else {
            temp.add(movies.get(j));
            j++;
        }
    }
    
    while (i <= mid) {
        temp.add(movies.get(i));
        i++;
    }
    
    while (j <= right) {
        temp.add(movies.get(j));
        j++;
    }
    
    for (int k = 0; k < temp.size(); k++) {
        movies.set(left + k, temp.get(k));
    }
}




// Radix Sort
public void radixSortByYear() {
    if (movies.isEmpty()) return;
    
    int minYear = movies.get(0).releaseYear;
    int maxYear = movies.get(0).releaseYear;
    for (Movie movie : movies) {
        if (movie.releaseYear < minYear) minYear = movie.releaseYear;
        if (movie.releaseYear > maxYear) maxYear = movie.releaseYear;
    }
    
    int range = maxYear - minYear + 1;
    int[] count = new int[range];
    ArrayList<Movie> output = new ArrayList<Movie>(Collections.nCopies(movies.size(), null));
    
    for (Movie movie : movies) {
        count[movie.releaseYear - minYear]++;
    }
    
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }
    
    for (int i = movies.size() - 1; i >= 0; i--) {
        output.set(count[movies.get(i).releaseYear - minYear] - 1, movies.get(i));
        count[movies.get(i).releaseYear - minYear]--;
    }
    
    for (int i = 0; i < movies.size(); i++) {
        movies.set(i, output.get(i));
    }
}


















	
}

public class Main {
	public static void main(String[] args) {
		ArrayList<Movie> movieList = new ArrayList<>();

		try {
			BufferedReader br = new BufferedReader(new FileReader("imdb_top_1000.csv"));
			String line;
			boolean firstLine = true;

			while ((line = br.readLine()) != null) {
				// Saltar encabezado
				if (firstLine) {
					firstLine = false;
					continue;
				}

				// Dividir linea
				String[] values = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)");

				try {
					String title = values[1].replace("\"", "");
					String genre = values[5].replace("\"", "");
					String director = values[9].replace("\"", "");
					int year = Integer.parseInt(values[2].trim());
					double rating = Double.parseDouble(values[6].trim());

					Movie m = new Movie(title, director, genre, year, rating);
					movieList.add(m);
				} catch (Exception e) {
					continue; // ignorar lineas no validas
				}
			}

			br.close();
		} catch (IOException e) {
			System.out.println("Error al leer el archivo: " + e.getMessage());
		}

		// Crear el catalogo
		MovieCatalog catalog = new MovieCatalog(movieList);
		System.out.println("Peliculas cargadas: " + movieList.size());


	}
}



import java.util.*;
import java.io.*;

class Movie {
	// atributos
	String title;
	String director;
	String genre;
	int releaseYear;
	double rating;

	// Constructor
	Movie(String title, String director, String genre, int releaseYear, double rating) {
		this.title = title;
		this.director = director;
		this.genre = genre;
		this.releaseYear = releaseYear;
		this.rating = rating;
	}
}

class MovieCatalog {

	// atributos
	ArrayList<Movie> movies;
	String sortedByAttribute;

	// Constructor
	MovieCatalog(ArrayList<Movie> movies) {
		this.movies = movies;
		this.sortedByAttribute = null;
	}

	// Metodos
	public ArrayList<Movie> getMoviesByRating(double rating) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("rating".equalsIgnoreCase(sortedByAttribute)) {
			// busqueda binaria
			int left = 0;
			int right = movies.size() - 1;

			while (left <= right) {
				int mid = (left + right) / 2;
				double midRating = movies.get(mid).rating;

				if (Math.abs(midRating - rating) <= 0.1) {

					for (int i = mid; i >= 0 && Math.abs(movies.get(i).rating - rating) <= 0.1; i--) {
						if (!result.contains(movies.get(i))) result.add(movies.get(i));
					}
					for (int i = mid + 1; i < movies.size() && Math.abs(movies.get(i).rating - rating) <= 0.1; i++) {
						result.add(movies.get(i));
					}
					break;
				} else if (midRating < rating) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
		} else {
			// busqueda lineal
			for (int i = 0; i < movies.size(); i++) {
				if (Math.abs(movies.get(i).rating - rating) <= 0.1) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}//si esta ordenado por rating busqueda binaria, de lo contrario lineal

	public ArrayList<Movie> getMoviesByRatingRange(double lowerRating, double higherRating) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("rating".equalsIgnoreCase(sortedByAttribute)) {
			for (int i = 0; i < movies.size(); i++) {
				double r = movies.get(i).rating;
				if (r >= lowerRating && r <= higherRating) {
					result.add(movies.get(i));
				}
			}
		} else {
			for (int i = 0; i < movies.size(); i++) {
				double r = movies.get(i).rating;
				if (r >= lowerRating && r <= higherRating) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}//si esta ordenado por rating busqueda binaria, de lo contrario lineal


	public ArrayList<Movie> getMoviesByGenre(String genre) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("genre".equalsIgnoreCase(sortedByAttribute)) {
			int left = 0;
			int right = movies.size() - 1;

			while (left <= right) {
				int mid = (left + right) / 2;
				int cmp = movies.get(mid).genre.compareToIgnoreCase(genre);

				if (cmp == 0) {
					for (int i = mid; i >= 0 && movies.get(i).genre.equalsIgnoreCase(genre); i--) {
						result.add(movies.get(i));
					}
					for (int i = mid + 1; i < movies.size() && movies.get(i).genre.equalsIgnoreCase(genre); i++) {
						result.add(movies.get(i));
					}
					break;
				} else if (cmp < 0) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
		} else {
			for (int i = 0; i < movies.size(); i++) {
				if (movies.get(i).genre.equalsIgnoreCase(genre)) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}


	public ArrayList<Movie> getMoviesByDirector(String director) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("director".equalsIgnoreCase(sortedByAttribute)) {
			int left = 0, right = movies.size() - 1;
			while (left <= right) {
				int mid = (left + right) / 2;
				int cmp = movies.get(mid).director.compareToIgnoreCase(director);

				if (cmp == 0) {
					for (int i = mid; i >= 0 && movies.get(i).director.equalsIgnoreCase(director); i--) {
						result.add(movies.get(i));
					}
					for (int i = mid + 1; i < movies.size() && movies.get(i).director.equalsIgnoreCase(director); i++) {
						result.add(movies.get(i));
					}
					break;
				} else if (cmp < 0) left = mid + 1;
				else right = mid - 1;
			}
		} else {
			for (int i = 0; i < movies.size(); i++) {
				if (movies.get(i).director.equalsIgnoreCase(director)) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}


	public ArrayList<Movie> getMoviesByYear(int year) {
		ArrayList<Movie> result = new ArrayList<>();

		if ("year".equalsIgnoreCase(sortedByAttribute)) {
			int left = 0, right = movies.size() - 1;
			while (left <= right) {
				int mid = (left + right) / 2;
				int midYear = movies.get(mid).releaseYear;

				if (midYear == year) {
					for (int i = mid; i >= 0 && movies.get(i).releaseYear == year; i--) {
						result.add(movies.get(i));
					}
					for (int i = mid + 1; i < movies.size() && movies.get(i).releaseYear == year; i++) {
						result.add(movies.get(i));
					}
					break;
				} else if (midYear < year) left = mid + 1;
				else right = mid - 1;
			}
		} else {
			for (int i = 0; i < movies.size(); i++) {
				if (movies.get(i).releaseYear == year) {
					result.add(movies.get(i));
				}
			}
		}
		return result;
	}

    public void sortByAlgorithm(String algorithm, String attribute) {
}

	
}

public class Main {
	public static void main(String[] args) {
		ArrayList<Movie> movieList = new ArrayList<>();

		try {
			BufferedReader br = new BufferedReader(new FileReader("imdb_top_1000.csv"));
			String line;
			boolean firstLine = true;

			while ((line = br.readLine()) != null) {
				// Saltar encabezado
				if (firstLine) {
					firstLine = false;
					continue;
				}

				// Dividir linea
				String[] values = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)");

				try {
					String title = values[1].replace("\"", "");
					String genre = values[5].replace("\"", "");
					String director = values[9].replace("\"", "");
					int year = Integer.parseInt(values[2].trim());
					double rating = Double.parseDouble(values[6].trim());

					Movie m = new Movie(title, director, genre, year, rating);
					movieList.add(m);
				} catch (Exception e) {
					continue; // ignorar lineas no validas
				}
			}

			br.close();
		} catch (IOException e) {
			System.out.println("Error al leer el archivo: " + e.getMessage());
		}

		// Crear el catalogo
		MovieCatalog catalog = new MovieCatalog(movieList);
		System.out.println("Peliculas cargadas: " + movieList.size());


	}
}




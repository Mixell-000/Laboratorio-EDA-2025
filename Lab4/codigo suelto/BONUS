
import java.util.*;
import java.io.*;

class Paciente implements Comparable<Paciente> {
	// atributos
	String id;
	String nombre;
	int categoria;
	long tiempoLlegada;
	Stack<String> historialCambios = new Stack<>();

	//constructor
	Paciente(String id,String nombre, int categoria, long tiempoLlegada) {
		this.id = id;
		this.nombre = nombre;
		this.categoria = categoria;
		this.tiempoLlegada = tiempoLlegada;
	}

	//metodos
	void registrarCambio(String descripcion) {
		historialCambios.push(descripcion + " " + new Date());
	}

	public int compareTo(Paciente o) {
		if (this.categoria != o.categoria) {
			return this.categoria - o.categoria;
		}
		return Long.compare(this.tiempoLlegada, o.tiempoLlegada);
	}
} //La clase Paciente debe implementar la interfaz Comparable<Paciente>

class ColaPrioridadPacientes {

	// Atributos
	Paciente[] pacientes;
	int tamano;

	// Constructor
	ColaPrioridadPacientes(int capacidadInicial) {
		pacientes = new Paciente[capacidadInicial];
		tamano = 0;
	}

	void insertar(Paciente p) {
		if (tamano == pacientes.length) {
			Paciente[] nuevo = new Paciente[pacientes.length * 2];
			for (int i = 0; i < pacientes.length; i++) {
				nuevo[i] = pacientes[i];
			}
			pacientes = nuevo;
		}


		pacientes[tamano] = p;


		int i = tamano;
		while (i > 0) {
			int padre = (i - 1) / 2;
			if (pacientes[i].compareTo(pacientes[padre]) < 0) {
				Paciente temp = pacientes[i];
				pacientes[i] = pacientes[padre];
				pacientes[padre] = temp;
				i = padre;
			} else {
				break;
			}
		}

		tamano++;
	}


	Paciente extraerMin() {
		if (estaVacia()) return null;

		Paciente min = pacientes[0];
		pacientes[0] = pacientes[tamano - 1];
		tamano--;


		int i = 0;
		while (true) {
			int izq = 2 * i + 1;
			int der = 2 * i + 2;
			int menor = i;

			if (izq < tamano && pacientes[izq].compareTo(pacientes[menor]) < 0) {
				menor = izq;
			}
			if (der < tamano && pacientes[der].compareTo(pacientes[menor]) < 0) {
				menor = der;
			}

			if (menor != i) {
				Paciente temp = pacientes[i];
				pacientes[i] = pacientes[menor];
				pacientes[menor] = temp;
				i = menor;
			} else {
				break;
			}
		}

		return min;
	}
	
	
	
	
	
	
	    // BONUS: Promociona prioridad a quienes llevan >= umbralMin minutos
    void promoverPorEspera(long tiempoActual, int umbralMin) {

        for (int i = 0; i < tamano; i++) {

            Paciente p = pacientes[i];
            if (p == null) continue;

            long espera = tiempoActual - p.tiempoLlegada;

            // Cumple 3 horas y no es ya el más urgente
            if (espera >= umbralMin && p.categoria > 1) {

                p.categoria--;  // sube prioridad (ej: C5->C4, C4->C3...)

                // Reacomodar hacia arriba
                int j = i;
                while (j > 0) {
                    int padre = (j - 1) / 2;
                    if (pacientes[j].compareTo(pacientes[padre]) < 0) {
                        Paciente tmp = pacientes[j];
                        pacientes[j] = pacientes[padre];
                        pacientes[padre] = tmp;
                        j = padre;
                    } else break;
                }
            }
        }
    }

	
	
	
	
	
	
	
	
	
	


	Paciente obtenerMin() {
		if (estaVacia()) return null;
		return pacientes[0];
	}


	boolean estaVacia() {
		if(tamano == 0) {
			return true;
		}
		else {
			return false;
		}
	}
}

class HashPacientesEncadenado {

	// Atributos
	LinkedList<Map.Entry<String, Paciente>>[] tabla;
	int capacidad;
	int tamano;

	// Constructor
	HashPacientesEncadenado(int capacidad) {
		this.capacidad = capacidad;
		this.tamano = 0;
		tabla = new LinkedList[capacidad];
		for (int i = 0; i < capacidad; i++) {
			tabla[i] = new LinkedList<>();
		}
	}

	// metodos

	public Paciente put(String id, Paciente p) {
		int indice = Math.abs(id.hashCode() % capacidad);
		LinkedList<Map.Entry<String, Paciente>> lista = tabla[indice];

		for (Map.Entry<String, Paciente> e : lista) {
			if (e.getKey().equals(id)) {
				Paciente anterior = e.getValue();
				((AbstractMap.SimpleEntry<String, Paciente>) e).setValue(p);
				return anterior;
			}
		}

		lista.add(new AbstractMap.SimpleEntry<>(id, p));
		tamano++;
		return null;
	}

	public Paciente get(Object id) {
		if (!(id instanceof String)) return null;
		int indice = Math.abs(((String) id).hashCode() % capacidad);
		LinkedList<Map.Entry<String, Paciente>> lista = tabla[indice];

		for (Map.Entry<String, Paciente> e : lista) {
			if (e.getKey().equals(id)) {
				return e.getValue();
			}
		}
		return null;
	}

	public Paciente remove(Object id) {
		if (!(id instanceof String)) return null;
		int indice = Math.abs(((String) id).hashCode() % capacidad);
		LinkedList<Map.Entry<String, Paciente>> lista = tabla[indice];

		Iterator<Map.Entry<String, Paciente>> it = lista.iterator();
		while (it.hasNext()) {
			Map.Entry<String, Paciente> e = it.next();
			if (e.getKey().equals(id)) {
				Paciente eliminado = e.getValue();
				it.remove();
				tamano--;
				return eliminado;
			}
		}
		return null;
	}

	public int size() {
		return tamano;
	}
	public boolean isEmpty() {
		return tamano == 0;
	}
	public boolean containsKey(Object key) {
		return get(key) != null;

	}

}

class HashPacientesSondeoLineal {

	Paciente[] tabla;
	int capacidad;
	int tamano;

	HashPacientesSondeoLineal(int capacidad) {
		this.capacidad = capacidad;
		tabla = new Paciente[capacidad];
		tamano = 0;
	}

	public Paciente put(String id, Paciente p) {
		int indice = Math.abs(id.hashCode() % capacidad);
		int inicio = indice;

		while (tabla[indice] != null) {
			if (tabla[indice].id.equals(id)) {
				Paciente anterior = tabla[indice];
				tabla[indice] = p;
				return anterior;
			}
			indice = (indice + 1) % capacidad;
			if (indice == inicio) return null;
		}

		tabla[indice] = p;
		tamano++;
		return null;
	}

	public Paciente get(Object key) {
		if (!(key instanceof String)) return null;
		String id = (String) key;
		int indice = Math.abs(id.hashCode() % capacidad);
		int inicio = indice;

		while (tabla[indice] != null) {
			if (tabla[indice].id.equals(id)) {
				return tabla[indice];
			}
			indice = (indice + 1) % capacidad;
			if (indice == inicio) break;
		}

		return null;
	}

	public Paciente remove(Object key) {
		if (!(key instanceof String)) return null;
		String id = (String) key;
		int indice = Math.abs(id.hashCode() % capacidad);
		int inicio = indice;

		while (tabla[indice] != null) {
			if (tabla[indice].id.equals(id)) {
				Paciente eliminado = tabla[indice];
				tabla[indice] = null;
				tamano--;


				int i = (indice + 1) % capacidad;
				while (tabla[i] != null) {
					Paciente temp = tabla[i];
					tabla[i] = null;
					tamano--;
					put(temp.id, temp);
					i = (i + 1) % capacidad;
				}

				return eliminado;
			}
			indice = (indice + 1) % capacidad;
			if (indice == inicio) break;
		}

		return null;
	}

	public int size() {
		return tamano;
	}
	public boolean isEmpty() {
		return tamano == 0;
	}
	public boolean containsKey(Object key) {
		return get(key) != null;
	}


}

class ArbolPacientes {

    class NodoArbol {
        Paciente paciente;
        NodoArbol izq, der;

        NodoArbol(Paciente p) {
            this.paciente = p;
        }
    } // clase interna para el nodo
    
    //atributo

    NodoArbol raiz;

    //metodos

    void insertar(Paciente p) {
        if (raiz == null) {
            raiz = new NodoArbol(p);
            return;
        }

        NodoArbol actual = raiz;
        while (true) {
            if (p.id.compareTo(actual.paciente.id) < 0) {
                if (actual.izq == null) {
                    actual.izq = new NodoArbol(p);
                    break;
                }
                actual = actual.izq;
            } else if (p.id.compareTo(actual.paciente.id) > 0) {
                if (actual.der == null) {
                    actual.der = new NodoArbol(p);
                    break;
                }
                actual = actual.der;
            } else {
                break;
            }
        }
    }

    Paciente buscar(String id) {
        NodoArbol n = raiz;
        while (n != null) {
            int a = id.compareTo(n.paciente.id);
            if (a == 0) return n.paciente;
            else if (a < 0) n = n.izq;
            else n = n.der;
        }
        return null;
    }

    List<Paciente> obtenerPacientesEnOrden() {
        List<Paciente> lista = new ArrayList<>();
        Stack<NodoArbol> pila = new Stack<>();
        NodoArbol actual = raiz;

        while (actual != null || !pila.isEmpty()) {
            while (actual != null) {
                pila.push(actual);
                actual = actual.izq;
            }
            actual = pila.pop();
            lista.add(actual.paciente);
            actual = actual.der;
        }

        return lista;
    }//In-Order
}

class Hospital {

    // Atributos
    HashPacientesEncadenado salaEspera;  
    ArbolPacientes historial;
    ColaPrioridadPacientes colaAtencion; 
    
    int capacidadInicial;

    // Constructor
    Hospital(int capacidadInicial) {
        this.capacidadInicial = capacidadInicial;
        this.salaEspera = new HashPacientesEncadenado(capacidadInicial);
        this.colaAtencion = new ColaPrioridadPacientes(capacidadInicial);
        this.historial = new ArbolPacientes();
    }

    //metodos

    void registrarPaciente(String id, String nombre, int categoria) {
        long tiempo = System.currentTimeMillis();
        Paciente p = new Paciente(id, nombre, categoria, tiempo);

        salaEspera.put(id, p);
        colaAtencion.insertar(p);
        p.registrarCambio("Registrado en el hospital");
    }

    Paciente atenderSiguiente() {
        if (colaAtencion.estaVacia()) {
            System.out.println("No hay pacientes para atender.");
            return null;
        }

        Paciente siguiente = colaAtencion.extraerMin();
        salaEspera.remove(siguiente.id);
        historial.insertar(siguiente);
        siguiente.registrarCambio("Paciente atendido y dado de alta");

        System.out.println("Atendiendo paciente: " + siguiente.nombre + " (ID: " + siguiente.id + ")");
        return siguiente;
    }

    Paciente buscarPacienteActivo(String id) {
        return salaEspera.get(id);
    }

    Paciente buscarPacienteHistorico(String id) {
        return historial.buscar(id);
    }


}

public class Main {

    static Random rnd = new Random(42); // Semilla 42

    public static void main(String[] args) {

        System.out.println(" 1 - 1 - 1 ");
        simulacionDiaHospital(1);

        System.out.println(" 2 - 2 - 2 ");
        simulacionDiaHospital(2);
    }

    static void simulacionDiaHospital(int escenario) {

        int capacidad = 10007;
        Hospital hospital = new Hospital(capacidad);

        int intervaloLlegada = (escenario == 1) ? 10 : 8; 
        int intervaloAtencion = 15; 


        int[] atendidosCat = new int[6];
        int[] enEsperaCat = new int[6];
        long[] esperaTotalCat = new long[6];
        int[] contEsperaCat = new int[6];

        int contadorPacientes = 0;

        // minuto a minuto
        for (int t = 0; t <= 1440; t++) {

hospital.colaAtencion.promoverPorEspera(t, 180);

            if (t % intervaloLlegada == 0) {
                
                
                
                int categoria = generarCategoria();
                String id = "P" + contadorPacientes;
                String nombre = "Paciente_" + contadorPacientes;
                Paciente p = new Paciente(id, nombre, categoria, t);

                hospital.salaEspera.put(id, p);
                hospital.colaAtencion.insertar(p);

                contadorPacientes++;
            }

            if (t % intervaloAtencion == 0) {

                Paciente atendido = hospital.colaAtencion.extraerMin();
                if (atendido != null) {

                    hospital.salaEspera.remove(atendido.id);
                    hospital.historial.insertar(atendido);

                    long espera = t - atendido.tiempoLlegada;

                    if (atendido.categoria >= 1 && atendido.categoria <= 5) {
                        atendidosCat[atendido.categoria]++;
                        esperaTotalCat[atendido.categoria] += espera;
                        contEsperaCat[atendido.categoria]++;
                    }
                }
            }
        }

        // Recorremos la tabla de encadenamiento para contar los que quedaron en sala de espera
        for (int i = 0; i < hospital.salaEspera.capacidad; i++) {
            LinkedList<Map.Entry<String, Paciente>> lista = hospital.salaEspera.tabla[i];
            if (lista == null) continue;
            for (Map.Entry<String, Paciente> entry : lista) {
                Paciente p = entry.getValue();
                if (p != null && p.categoria >= 1 && p.categoria <= 5) {
                    enEsperaCat[p.categoria]++;
                }
            }
        }


        System.out.println("\n--- RESULTADOS ESCENARIO " + escenario + " ---");

        System.out.println("\nPacientes atendidos por categoría:");
        for (int c = 1; c <= 5; c++) {
            System.out.println("C" + c + ": " + atendidosCat[c]);
        }

        System.out.println("\nPacientes en espera al final:");
        for (int c = 1; c <= 5; c++) {
            System.out.println("C" + c + ": " + enEsperaCat[c]);
        }

        System.out.println("\nTiempos de espera promedio por categoría:");
        for (int c = 1; c <= 5; c++) {
            if (contEsperaCat[c] > 0)
                System.out.println("C" + c + ": " + (esperaTotalCat[c] / contEsperaCat[c]) + " min");
            else
                System.out.println("C" + c + ": (sin datos)");
        }
    }

    static int generarCategoria() {
        int x = rnd.nextInt(100);

        if (x < 10) return 1;          // 10%
        else if (x < 25) return 2;     // 15%
        else if (x < 43) return 3;     // 18%
        else if (x < 70) return 4;     // 27%
        else return 5;                 // 30%
    }
}
